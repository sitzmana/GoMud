// ///////////////////////////////////////////////////////////////
// NOTE: Do not run this file directly.
//
//	This is intended to be run by a "go generate" command
//	  off of the project root.
//	It automatically builds a list of includes that get written
//	  to modules/all-modules.go
//
// ///////////////////////////////////////////////////////////////
package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func main() {
	root := "modules"
	pkgs := []string{}

	entries, err := os.ReadDir(root)
	if err != nil {
		log.Fatal(err)
	}

	for _, d := range entries {
		if !d.IsDir() {
			continue
		}

		dir := filepath.Join(root, d.Name())

		// scan that one sub‚Äêdir for a .go file
		files, _ := os.ReadDir(dir)
		for _, f := range files {
			if !f.IsDir() && strings.HasSuffix(f.Name(), ".go") {
				pkgPath := filepath.ToSlash(dir) // e.g. "modules/foo"
				pkgs = append(pkgs, pkgPath)
				break
			}
		}
	}
	sort.Strings(pkgs)
	var buf bytes.Buffer
	buf.WriteString("// Code generated by go:generate; DO NOT EDIT.\n\n")
	buf.WriteString("// Generated with command: go generate\n")
	buf.WriteString("// (from the project root)\n\n")

	buf.WriteString("package modules\n\nimport (\n")
	for _, p := range pkgs {
		buf.WriteString(fmt.Sprintf("\t_ \"github.com/GoMudEngine/GoMud/%s\"\n", p))
	}
	buf.WriteString(")\n")

	if err := os.WriteFile("modules/all-modules.go", buf.Bytes(), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "error writing all-modules.go: %v\n", err)
		os.Exit(1)
	}
}
